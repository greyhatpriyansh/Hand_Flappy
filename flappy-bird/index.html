<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Palm-Controlled Flappy Bird</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 400px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            background: transparent;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            min-width: 120px;
        }

        .start-screen, .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            pointer-events: all;
        }

        .start-screen h1, .game-over h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .start-screen p, .game-over p {
            font-size: 16px;
            margin: 8px 0;
            max-width: 320px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 18px;
            background: #FFD700;
            color: #333;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px;
            height: 90px;
            border: 2px solid white;
            border-radius: 8px;
            overflow: hidden;
            background: black;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video */
        }

        .gesture-indicator {
            position: absolute;
            bottom: 110px;
            right: 10px;
            width: 120px;
            height: 35px;
            background: rgba(50,50,50,0.9);
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            border: 2px solid #666;
            color: white;
        }

        .gesture-indicator.open {
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .gesture-indicator.closed {
            background: linear-gradient(135deg, #F44336, #E91E63);
            color: white;
            border-color: #F44336;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
        }

        .hand-demo {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .hand-demo div {
            text-align: center;
            margin: 0 20px;
        }

        .hand-demo .emoji {
            font-size: 56px;
            margin-bottom: 10px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 100;
        }

        .confidence-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.2s;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading MediaPipe Hands...</div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div class="ui-overlay">
            <div class="score">Score: <span id="scoreValue">0</span></div>
            <div class="status-panel">
                <div>Camera: <span id="cameraStatus">Starting...</span></div>
                <div>MediaPipe: <span id="mediapipeStatus">Loading...</span></div>
                <div>Hand: <span id="handStatus">None</span></div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceBar"></div>
                </div>
            </div>
        </div>

        <div class="start-screen" id="startScreen">
            <h1>üñêÔ∏è MediaPipe Flappy Bird</h1>
            <p><strong>Accurate hand tracking powered by Google MediaPipe!</strong></p>
            
            <div class="hand-demo">
                <div>
                    <div class="emoji">üñêÔ∏è</div>
                    <p><strong>Open Hand</strong><br>Bird Flies Up</p>
                </div>
                <div>
                    <div class="emoji">‚úä</div>
                    <p><strong>Closed Fist</strong><br>Bird Falls Down</p>
                </div>
            </div>
            
            <p>Hold your hand clearly in front of the camera</p>
            <p><small>Uses MediaPipe Hands for precise gesture detection</small></p>
            <button class="btn" onclick="startGame()">Start Game</button>
            <button class="btn" onclick="testGesture()">Test Gestures</button>
        </div>

        <div class="game-over" id="gameOverScreen" style="display: none;">
            <h1>Game Over!</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>

        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
        </div>
        
        <div class="gesture-indicator" id="gestureIndicator">
            <span>No Hand Detected</span>
        </div>
    </div>

    <!-- MediaPipe Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameState = 'start';
        let score = 0;
        let gameSpeed = 2;

        // Bird object
        const bird = {
            x: 80,
            y: 300,
            width: 30,
            height: 30,
            velocity: 0,
            gravity: 0.5,
            liftPower: -0.9,
            maxUpSpeed: -7,
            maxDownSpeed: 8,
            color: '#FFD700'
        };

        // Pipes array
        let pipes = [];
        const pipeWidth = 60;
        const pipeGap = 180;
        let pipeTimer = 0;

        // Hand tracking variables
        let handGesture = 'none'; // 'open', 'closed', 'none'
        let handConfidence = 0;
        let frameCount = 0;
        let hands;
        let camera;

        // MediaPipe Hands setup
        function initializeMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);
            document.getElementById('mediapipeStatus').textContent = 'Ready';
        }

        // Initialize camera
        async function initCamera() {
            try {
                const video = document.getElementById('video');
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        if (hands) {
                            await hands.send({image: video});
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                document.getElementById('cameraStatus').textContent = 'Active';
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                document.getElementById('cameraStatus').textContent = 'Failed';
            }
        }

        // Hand results callback
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const gesture = detectHandGesture(landmarks);
                handGesture = gesture.type;
                handConfidence = gesture.confidence;
                
                document.getElementById('handStatus').textContent = handGesture.charAt(0).toUpperCase() + handGesture.slice(1);
                document.getElementById('confidenceBar').style.width = (handConfidence * 100) + '%';
            } else {
                handGesture = 'none';
                handConfidence = 0;
                document.getElementById('handStatus').textContent = 'None';
                document.getElementById('confidenceBar').style.width = '0%';
            }
            
            updateGestureUI();
        }

        // Gesture detection using hand landmarks
        function detectHandGesture(landmarks) {
            // Get key finger tip and joint positions
            const fingerTips = [
                landmarks[4],  // Thumb tip
                landmarks[8],  // Index finger tip
                landmarks[12], // Middle finger tip
                landmarks[16], // Ring finger tip
                landmarks[20]  // Pinky tip
            ];
            
            const fingerJoints = [
                landmarks[3],  // Thumb joint
                landmarks[6],  // Index finger joint
                landmarks[10], // Middle finger joint
                landmarks[14], // Ring finger joint
                landmarks[18]  // Pinky joint
            ];
            
            const wrist = landmarks[0];
            const palmBase = landmarks[9]; // Middle finger base
            
            // Count extended fingers
            let extendedFingers = 0;
            let fingerConfidences = [];
            
            // Check each finger (skip thumb for now as it's trickier)
            for (let i = 1; i < 5; i++) {
                const tip = fingerTips[i];
                const joint = fingerJoints[i];
                const base = (i === 1) ? landmarks[5] : landmarks[i * 4 - 3];
                
                // Calculate if finger is extended
                const tipToPalm = Math.sqrt(
                    Math.pow(tip.x - palmBase.x, 2) + 
                    Math.pow(tip.y - palmBase.y, 2)
                );
                
                const jointToPalm = Math.sqrt(
                    Math.pow(joint.x - palmBase.x, 2) + 
                    Math.pow(joint.y - palmBase.y, 2)
                );
                
                // Finger is extended if tip is further from palm than joint
                if (tipToPalm > jointToPalm * 1.1) {
                    extendedFingers++;
                    fingerConfidences.push(tipToPalm / jointToPalm);
                }
            }
            
            // Check thumb separately (different logic needed)
            const thumbTip = landmarks[4];
            const thumbJoint = landmarks[3];
            const indexBase = landmarks[5];
            
            const thumbToIndex = Math.sqrt(
                Math.pow(thumbTip.x - indexBase.x, 2) + 
                Math.pow(thumbTip.y - indexBase.y, 2)
            );
            
            const thumbJointToIndex = Math.sqrt(
                Math.pow(thumbJoint.x - indexBase.x, 2) + 
                Math.pow(thumbJoint.y - indexBase.y, 2)
            );
            
            if (thumbToIndex > thumbJointToIndex * 0.8) {
                extendedFingers++;
                fingerConfidences.push(thumbToIndex / thumbJointToIndex);
            }
            
            // Calculate overall confidence
            const avgConfidence = fingerConfidences.length > 0 ? 
                fingerConfidences.reduce((a, b) => a + b) / fingerConfidences.length : 0;
            
            // Determine gesture
            if (extendedFingers >= 4) {
                return {
                    type: 'open',
                    confidence: Math.min(avgConfidence, 1.0)
                };
            } else if (extendedFingers <= 1) {
                return {
                    type: 'closed',
                    confidence: Math.min(1.2 - avgConfidence, 1.0)
                };
            } else {
                return {
                    type: 'partial',
                    confidence: 0.5
                };
            }
        }

        function updateGestureUI() {
            const indicator = document.getElementById('gestureIndicator');
            
            if (handGesture === 'open') {
                indicator.innerHTML = '<span>üñêÔ∏è OPEN - Flying Up!</span>';
                indicator.className = 'gesture-indicator open';
            } else if (handGesture === 'closed') {
                indicator.innerHTML = '<span>‚úä CLOSED - Falling</span>';
                indicator.className = 'gesture-indicator closed';
            } else if (handGesture === 'partial') {
                indicator.innerHTML = '<span>ü§è PARTIAL - Falling</span>';
                indicator.className = 'gesture-indicator';
            } else {
                indicator.innerHTML = '<span>‚ùì No Hand Detected</span>';
                indicator.className = 'gesture-indicator';
            }
        }

        // Game functions
        function createPipe() {
            const minHeight = 50;
            const maxHeight = canvas.height - pipeGap - minHeight;
            const height = Math.random() * (maxHeight - minHeight) + minHeight;
            
            pipes.push({
                x: canvas.width,
                topHeight: height,
                bottomY: height + pipeGap,
                bottomHeight: canvas.height - (height + pipeGap),
                passed: false
            });
        }

        function updateGame() {
            if (gameState !== 'playing') return;

            // Update bird based on hand gesture
            if (handGesture === 'open' && handConfidence > 0.6) {
                bird.velocity += bird.liftPower;
                if (bird.velocity < bird.maxUpSpeed) {
                    bird.velocity = bird.maxUpSpeed;
                }
            } else {
                bird.velocity += bird.gravity;
                if (bird.velocity > bird.maxDownSpeed) {
                    bird.velocity = bird.maxDownSpeed;
                }
            }

            bird.y += bird.velocity;

            // Update pipes
            pipeTimer++;
            if (pipeTimer > 150) { // Slightly slower pipe generation
                createPipe();
                pipeTimer = 0;
            }

            // Move pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= gameSpeed;
                
                if (!pipes[i].passed && pipes[i].x + pipeWidth < bird.x) {
                    pipes[i].passed = true;
                    score++;
                    document.getElementById('scoreValue').textContent = score;
                    
                    if (score % 5 === 0) {
                        gameSpeed += 0.1;
                    }
                }
                
                if (pipes[i].x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                }
            }

            checkCollisions();
        }

        function checkCollisions() {
            if (bird.y + bird.height > canvas.height || bird.y < 0) {
                gameOver();
                return;
            }

            for (let pipe of pipes) {
                if (bird.x < pipe.x + pipeWidth && 
                    bird.x + bird.width > pipe.x) {
                    
                    if (bird.y < pipe.topHeight || 
                        bird.y + bird.height > pipe.bottomY) {
                        gameOver();
                        return;
                    }
                }
            }
        }

        function drawGame() {
            // Clear and draw background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw animated clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const x = (i * 120 - frameCount * 0.3) % (canvas.width + 60);
                const y = 50 + Math.sin(i + frameCount * 0.01) * 20;
                drawCloud(x, y);
            }

            // Draw pipes with enhanced graphics
            for (let pipe of pipes) {
                // Pipe shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pipe.x + 3, 3, pipeWidth, pipe.topHeight);
                ctx.fillRect(pipe.x + 3, pipe.bottomY + 3, pipeWidth, pipe.bottomHeight);
                
                // Main pipe body
                ctx.fillStyle = '#228B22';
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, pipe.bottomHeight);
                
                // Pipe highlights
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(pipe.x + 2, 0, 8, pipe.topHeight);
                ctx.fillRect(pipe.x + 2, pipe.bottomY, 8, pipe.bottomHeight);
                
                // Pipe caps
                ctx.fillStyle = '#006400';
                ctx.fillRect(pipe.x - 5, Math.max(0, pipe.topHeight - 25), pipeWidth + 10, 25);
                ctx.fillRect(pipe.x - 5, pipe.bottomY, pipeWidth + 10, 25);
            }

            // Draw bird with enhanced animation
            ctx.save();
            ctx.translate(bird.x + bird.width/2, bird.y + bird.height/2);
            
            const rotation = Math.max(-0.5, Math.min(0.5, bird.velocity * 0.08));
            ctx.rotate(rotation);
            
            // Bird body color based on gesture
            if (handGesture === 'open') {
                ctx.fillStyle = '#FFD700';
            } else {
                ctx.fillStyle = '#FFA500';
            }
            
            // Bird body with rounded corners effect
            ctx.fillRect(-bird.width/2, -bird.height/2, bird.width, bird.height);
            
            // Wing animation
            const wingFlap = Math.sin(frameCount * 0.4) * 4;
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(-8, -3, 12, 10 + wingFlap);
            
            // Beak
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(bird.width/2 - 3, -2, 10, 4);
            
            // Eye
            ctx.fillStyle = 'white';
            ctx.fillRect(-bird.width/2 + 8, -bird.height/2 + 6, 10, 10);
            ctx.fillStyle = 'black';
            ctx.fillRect(-bird.width/2 + 10, -bird.height/2 + 8, 6, 6);
            
            ctx.restore();
            
            frameCount++;
        }

        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.arc(x + 15, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 30, y, 15, 0, Math.PI * 2);
            ctx.arc(x + 10, y - 10, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            resetGame();
        }

        function resetGame() {
            bird.y = 300;
            bird.velocity = 0;
            pipes = [];
            score = 0;
            pipeTimer = 0;
            gameSpeed = 2;
            frameCount = 0;
            document.getElementById('scoreValue').textContent = '0';
        }

        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function restartGame() {
            startGame();
        }

        function testGesture() {
            const originalText = document.getElementById('startScreen').innerHTML;
            document.getElementById('startScreen').innerHTML = `
                <h1>MediaPipe Gesture Test</h1>
                <p><strong>Test your hand gestures:</strong></p>
                <div class="hand-demo">
                    <div>
                        <div class="emoji">üñêÔ∏è</div>
                        <p>Open Hand<br><small>All fingers extended</small></p>
                    </div>
                    <div>
                        <div class="emoji">‚úä</div>
                        <p>Closed Fist<br><small>All fingers curled</small></p>
                    </div>
                </div>
                <p>Watch the gesture indicator and confidence bar</p>
                <p id="testTimer">20</p>
                <p><small>MediaPipe tracks 21 hand landmarks for accurate detection</small></p>
            `;
            
            let countdown = 20;
            const timer = setInterval(() => {
                countdown--;
                const timerElement = document.getElementById('testTimer');
                if (timerElement) {
                    timerElement.textContent = countdown;
                }
                if (countdown <= 0) {
                    clearInterval(timer);
                    document.getElementById('startScreen').innerHTML = originalText;
                }
            }, 1000);
        }

        // Initialize everything
        async function initialize() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                await initializeMediaPipe();
                await initCamera();
                
                document.getElementById('loading').style.display = 'none';
                gameLoop();
                
            } catch (error) {
                console.error('Initialization failed:', error);
                document.getElementById('loading').textContent = 'Initialization failed. Please refresh the page.';
            }
        }

        // Keyboard backup for testing
        document.addEventListener('keydown', (e) => {
            if (gameState === 'playing') {
                if (e.code === 'Space') {
                    e.preventDefault();
                    handGesture = 'open';
                    handConfidence = 1.0;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === 'playing' && e.code === 'Space') {
                handGesture = 'closed';
                handConfidence = 1.0;
            }
        });

        // Start initialization when page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
